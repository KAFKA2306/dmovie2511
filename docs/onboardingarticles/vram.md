VRAM が足りないって何？
動画生成や画像生成で失敗しないための、やさしい「掛け算」入門ガイド
=================================

> 対象読者：
>
> * 「VRAM ってそもそも何？」という人
> * Stable Diffusion / Wan / ComfyUI などで画像・動画生成をしている人
> * OOM（Out of Memory）エラーでよくコケてつらい人

専門用語はできるだけ噛み砕いて、「どう考えればいいか」「何を変えればいいか」までつなげていきます。

---

## 1. VRAM って何者？

ざっくりいうと：

* **VRAM = GPU 専用の作業机の広さ**
* 画像・動画・モデルの重さ・一時的な計算結果が、ぜんぶここに乗る
* 作業机が狭いのに、大きな図面（高解像度画像）や長いフィルム（動画）を一度に広げようとすると**机からはみ出して落ちる → OOM エラー**

CPU 側のメモリ（RAM）と概念は似ていますが、

* GPU の計算は「全部 VRAM の上で」行われる
* VRAM に乗らないものは、そもそも計算できない

というのがポイントです。

---

## 2. VRAM を決めているのは「要素の数 × 1要素のサイズ」

GPU が扱っているデータは、すべて「テンソル（多次元の配列）」です。

例えば、カラー写真 1 枚なら：

* 高さ = H
* 幅   = W
* チャンネル数 = 3（RGB）

なので、要素の数（ピクセルの数）は：

```text
要素数 = H × W × 3
```

1 要素あたり 2 バイト（fp16）なら、使うメモリ量は：

```text
メモリ量 ≒ 要素数 × 2バイト
```

ここで大事なのは、**「各次元は掛け算で効く」** ということです。

* 2 倍の解像度にすると
  → H も W も約 2 倍
  → ピクセル数は 4 倍
  → メモリも約 4 倍

という形で膨らみます。

---

## 3. 画像生成モデルのテンソル（静止画）

Stable Diffusion などの画像生成モデルは、内部ではこんな形のテンソルを扱っています：

```text
(バッチサイズ B, チャンネル数 C, 高さ H, 幅 W)
```

要素数は：

```text
要素数 = B × C × H × W
```

ここから分かること：

* **B（バッチサイズ）を 2 倍 → メモリもほぼ 2 倍**
* **H を 2 倍 & W を 2 倍 → メモリは 4 倍**
* C はモデルが決めているので、ユーザー側では基本いじれない

---

## 4. 動画生成モデルのテンソル（動画）

動画になるとさらに 1 次元増えます。
Wan などの動画モデルは、ざっくりこういう形を扱います：

```text
(バッチ B, フレーム数 F, チャンネル C, 高さ H, 幅 W)
```

要素数は：

```text
要素数 = B × F × C × H × W
```

ここで VRAM 的に効いてくるのがこの 3 つ：

```text
B（バッチサイズ）
F（フレーム数）
H × W（解像度）
```

つまり、動画生成では

* 高解像度
* 長い動画（フレーム数が多い）
* 複数本をまとめて生成（バッチサイズ > 1）

を同時にやると、
**掛け算で一気に VRAM が吹き飛ぶ** という構造になっています。

---

## 5. 拡散モデルとステップ数（steps）はどう関係する？

拡散モデル（Stable Diffusion / Wan など）は、

```text
ノイズからスタートして、
中間画像を何回も更新していくループ（ステップ）を回す
```

という動きをしています。

ざっくり pseudo-code にすると：

```python
x = 初期ノイズ

for step in range(steps):
    x = モデル(x, 条件テキストなど)
```

ここでポイントは：

* **1 ステップごとに使う VRAM（ピーク）はほぼ同じ**
* ステップが終わったら、そのステップの中間結果は解放される
* ステップ数を 50 → 30 に減らしても、

  * 1 ステップあたりのメモリはあまり変わらない
  * ループ回数が減るので「時間」は短くなる

つまり、

* **steps は「時間」に効くレバー**
* **ピーク VRAM にはあまり効かない**

と覚えておくと、設計のとき混乱しません。

---

## 6. 動画モデルの中で、本当に重いところ

Wan などの動画モデルは、中で Transformer（自己注意）を使っています。

ざっくりいうと：

1. 動画の潜在表現（フレーム × 高さ × 幅）を「パッチ」に分解して、
   1 本の長い「トークン列」にする（文章の単語列のようなもの）
2. そのトークン列に対して、自己注意（self-attention）を何層もかける

このときのトークン数 N は、おおざっぱに：

```text
N ≒ フレーム数（潜在） × 高さ方向のパッチ数 × 幅方向のパッチ数
```

高さ方向のパッチ数や幅方向のパッチ数は、
元の解像度 H × W に比例します。

なので、

```text
N ≒ 定数 × F × H × W
```

と考えられます。

自己注意は「トークン同士の関係」を全部見るので、
内部で扱う行列の大きさはおおよそ

```text
N × N
```

のイメージです。

そこから分かる直感的な指針は：

* 解像度 H と W を上げる → N が増える → N × N の世界で一気に重くなる
* フレーム数 F（潜在フレーム）が増える → N が増える → 同じく激増

実際の Wan の実装や解析でも、

* 例えば「832 × 480 、81 フレーム」の設定で
  トークン数が 3 万以上になる
* 解像度をさらに上げると、あっという間に VRAM が足りなくなる

という報告が多くあります。

---

## 7. OOM（Out of Memory）エラーとは何か

画像・動画生成でよく見るエラー：

* `torch.OutOfMemoryError`
* 「This error means you ran out of memory on your GPU.」
* ComfyUI や WebUI だとポップアップや赤字ログで出る

これは、

> 今の設定（解像度 / フレーム数 / モデルサイズ / バッチサイズ など）では、
> GPU の作業机（VRAM）に乗り切らなかった

というただそれだけです。
ハードウェアが壊れたわけではありません。

---

## 8. 実務で使える「掛け算の指針」

ここからは、誰でも使える「計算のしかた」と「判断の仕方」です。

### 8-1. 基準構成（失敗中の構成）を 1 つ決める

例えば、あなたが OOM を出した構成をこう置きます：

```text
F_ref = 81        （フレーム数）
H_ref = 720       （高さ）
W_ref = 1280      （幅）

基準負荷 S_ref = F_ref × H_ref × W_ref
```

この S_ref が「今の VRAM では無理だった重さ」です。

### 8-2. 候補構成の「重さ」を比率で見る

別の構成（F, H, W）を試したいとき、
同じモデル・同じ精度（fp16/bf16）なら

```text
S = F × H × W

比率 r = S / S_ref
      = (F / F_ref) × (H / H_ref) × (W / W_ref)
```

と考えられます。

感覚としては：

* r < 1 … 基準より軽い（VRAM 使用量が減る）
* r ≪ 1 … かなり余裕
* r > 1 … 基準より重い（たぶんまた OOM）

これだけでも、だいぶ判断しやすくなります。

---

## 9. 具体例：1280×720×81 フレームが OOM だった場合

さっきの基準：

```text
F_ref = 81
H_ref = 720
W_ref = 1280
```

に対して、「解像度だけ落とす」案を考えます。

### 9-1. 832×468 に落とす（フレーム数はそのまま）

```text
F = 81
H = 468
W = 832

r = (81 / 81) × (468 / 720) × (832 / 1280)
  ≒ 1.0 × 0.65 × 0.65
  ≒ 0.42
```

→ 元の約 42% の負荷になります。

ポイント：

* フレーム数 F は一切削っていない
* 解像度を下げただけで、負荷が半分以下

「時間はかかってもいいけど、映像の長さは守りたい」
というときは、このように **まず解像度だけ落とす** のが筋が良いです。

---

## 10. 「steps はどうすればいいの？」の答え

ここまで見た通り、ピーク VRAM は主に

```text
モデルサイズ × (F × H × W)
```

で決まります。

ステップ数 steps は「その重い処理を何回繰り返すか」の回数なので、

* VRAM というより **計算時間に効く**
* OOM を避けるために下げる、というより

  * テスト時：小さめ（20〜30）
  * 本番：クオリティを見ながら増やす（40〜50 など）

という「時間とのトレードオフ」で決めるのが自然です。

---

## 11. 初心者向け・具体アクションチェックリスト

最後に、「じゃあどう設定すればいいの？」を
チェックリスト形式でまとめます。

### 11-1. 画像生成（静止画）の場合

1. まず **バッチサイズを 1 にする**

2. 解像度を下のように目安にする（おおざっぱな目安）

   * VRAM 8GB 前後

     * 512×512 〜 768×512
   * VRAM 12GB 前後

     * 768×768 〜 1024×576
   * VRAM 16GB 以上

     * 1024×1024 〜 1344×768 など

3. OOM が出たら、優先順位はこの順番：

   1. 解像度を少し下げる
   2. 精度を fp16/bf16 にする（設定にあればオン）
   3. それでもダメならモデルを軽いものに変える（小さいモデル）

### 11-2. 動画生成（Wan など）の場合

1. **バッチサイズ 1** にする（同時に複数本作らない）

2. 使っているモデルやワークフローの「想定フレーム数」がある場合
   → 最初はそれを素直に守る（たとえば 81 フレームなど）

3. まずは **解像度だけ落として** 試す

   例：

   * 1280×720 で OOM → 832×480 → 640×360 → 512×512 など
   * 途中で一度動いた解像度を「自分の安全ライン」としてメモしておく

4. それでもダメなときだけ、フレーム数や秒数を短くすることを検討する

   * ただし、モデルが「固定フレーム前提」のときは注意（動作が不安定になる場合あり）

5. steps は：

   * テスト段階：20〜30（早く様子を見る）
   * 本番レンダリング：40〜50 に上げてクオリティと時間のバランスを見る
     → VRAM ではなく「時間との相談」

### 11-3. 共通の考え方

困ったときは、頭の中でこれを思い出すと整理しやすいです：

```text
VRAM に効くもの（優先的にいじる）

  1. 解像度 H × W
  2. フレーム数 F（動画）
  3. バッチサイズ B
  4. モデルの大きさ（パラメータ数）

時間に効くもの（VRAMというより所要時間）

  - steps（ステップ数）
```

---

## 12. まとめ

この文章で押さえてほしいポイントは 3 つです。

1. GPU の VRAM は「テンソルの要素数 × 1 要素のサイズ」で決まり、
   要素数は
   `B × F × C × H × W` の **掛け算** で増える
2. 動画生成では特に

   * 解像度 H × W
   * フレーム数 F
   * モデルサイズ
     が VRAM を大きく左右する
3. steps（ステップ数）は、主に「時間」に効くパラメータで、
   VRAM を減らしたいときに真っ先にいじるべきものではない

この「掛け算モデル」を頭に置いておくと、

* 設定を変えるときに「どのパラメータがどれくらい効くか」
* OOM になったときに「次にどれを下げればいいか」

を論理的に考えられるようになります。
